library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.NUMERIC_STD.ALL;

entity acc_linear_function is
    Port ( reset : in STD_LOGIC;
           clk : in STD_LOGIC;
           -- Input AXI Stream interface
           s_axis_tdata : in STD_LOGIC_VECTOR (7 downto 0);
           s_axis_tvalid : in STD_LOGIC;
           s_axis_tready : out STD_LOGIC;
           s_axis_tlast : in STD_LOGIC;
           -- Output AXI Stream interface
           m_axis_tdata : out STD_LOGIC_VECTOR (15 downto 0);
           m_axis_tvalid : out STD_LOGIC;
           m_axis_tready : in STD_LOGIC;
           m_axis_tlast : out STD_LOGIC);
end acc_linear_function;

architecture Behavioral of acc_linear_function is
    signal reg_a : std_logic_vector(7 downto 0);
    signal reg_b : std_logic_vector(7 downto 0);
    
    constant PIPELINE_DEPTH : natural := 3;
    signal tvalid_fifo : std_logic_vector(PIPELINE_DEPTH-1 downto 0);
    signal tlast_fifo  : std_logic_vector(PIPELINE_DEPTH-1 downto 0);
    
    signal reg_input   : std_logic_vector(7 downto 0);
    signal reg_product : std_logic_vector(15 downto 0);
    signal reg_output  : std_logic_vector(15 downto 0);
    
    signal buff_tdata  : std_logic_vector(7 downto 0);
    signal buff_tvalid : std_logic;
    signal buff_tlast  : std_logic;
    signal buff_flag   : std_logic;
    
    attribute mark_debug : string;

    attribute mark_debug of tvalid_fifo: signal is "true";
    attribute mark_debug of tlast_fifo: signal is "true";
    
    attribute mark_debug of reg_input: signal is "true";
    attribute mark_debug of reg_product: signal is "true";
    attribute mark_debug of reg_output: signal is "true";
    
    attribute mark_debug of buff_tdata: signal is "true";
    attribute mark_debug of buff_tvalid: signal is "true";
    attribute mark_debug of buff_tlast: signal is "true";
    attribute mark_debug of buff_flag: signal is "true";
   
begin
    reg_a <= std_logic_vector(to_signed(10, reg_a'length));
    reg_b <= std_logic_vector(to_signed( 5, reg_a'length));
    
    process (clk) is
    begin
        if (rising_edge(clk)) then
            if (reset = '1') then
                tvalid_fifo <= (others => '0');
                tlast_fifo  <= (others => '0');
                
                reg_input   <= (others => '0');
                reg_product <= (others => '0');
                reg_output  <= (others => '0');
                
                buff_tdata  <= (others => '0');
                buff_tvalid <= '0';
                buff_tlast  <= '0';
                buff_flag   <= '0';
            else
                if (tvalid_fifo(PIPELINE_DEPTH-1) = '0' or m_axis_tready = '1') then
                    -- 1st pipeline stage
                    if (buff_flag = '1') then
                        reg_input      <= buff_tdata;
                        tvalid_fifo(0) <= buff_tvalid;
                        tlast_fifo(0)  <= buff_tlast;
                        buff_flag <= '0';                       
                    else
                        reg_input      <= s_axis_tdata;
                        tvalid_fifo(0) <= s_axis_tvalid;
                        tlast_fifo(0)  <= s_axis_tlast;
                    end if;

                    -- 2nd pipeline stage
                    reg_product <= std_logic_vector(signed(reg_a) * signed(reg_input));
                    tvalid_fifo(1) <= tvalid_fifo(0);
                    tlast_fifo(1)  <= tlast_fifo(0);
                    
                    -- 3rd pipeline stage
                    reg_output <= std_logic_vector(signed(reg_product) + signed(reg_b));
                    tvalid_fifo(2) <= tvalid_fifo(1);
                    tlast_fifo(2)  <= tlast_fifo(1);
                else
                    if (buff_flag = '0') then
                        buff_tdata  <= s_axis_tdata;
                        buff_tvalid <= s_axis_tvalid;
                        buff_tlast  <= s_axis_tlast;
                        buff_flag <= '1';
                    end if;    
                end if; 
            end if;
        end if;
    end process;
    
    m_axis_tvalid <= tvalid_fifo(PIPELINE_DEPTH-1);
    m_axis_tlast  <= tlast_fifo(PIPELINE_DEPTH-1);
    m_axis_tdata  <= reg_output;
    
    process (clk) is
    begin
        if (rising_edge(clk)) then
            if (reset = '1') then
                s_axis_tready <= '0';
            else
                if (tvalid_fifo(PIPELINE_DEPTH-1) = '0' or m_axis_tready = '1') then
                    s_axis_tready <= '1';
                else
                    s_axis_tready <= '0';
                end if;
            end if;
        end if;
    end process;

end Behavioral;
